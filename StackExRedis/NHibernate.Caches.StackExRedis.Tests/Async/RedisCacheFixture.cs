//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Xml;
using System.Xml.Linq;
using NHibernate.Cache;
using NHibernate.Cache.Entry;
using NHibernate.Caches.Common.Tests;
using NHibernate.Collection;
using NHibernate.Engine;
using NHibernate.Persister.Entity;
using NHibernate.Type;
using NSubstitute;
using NUnit.Framework;

namespace NHibernate.Caches.StackExRedis.Tests
{
	using System.Threading.Tasks;
	public abstract partial class RedisCacheFixture : CacheFixture
	{

		[Test]
		public async Task TestEqualObjectsWithDifferentHashCodeAsync()
		{
			var value = "value";
			var obj1 = new CustomCacheKey(1, "test", false);
			var obj2 = new CustomCacheKey(1, "test", false);

			var cache = GetDefaultCache();

			await (cache.PutAsync(obj1, value, CancellationToken.None));
			Assert.That(await (cache.GetAsync(obj1, CancellationToken.None)), Is.EqualTo(value), "Unable to retrieved cached object for key obj1");
			Assert.That(await (cache.GetAsync(obj2, CancellationToken.None)), Is.EqualTo(value), "Unable to retrieved cached object for key obj2");
			await (cache.RemoveAsync(obj1, CancellationToken.None));
		}

		[Test]
		public async Task TestEqualObjectsWithDifferentHashCodeAndUseHashCodeGlobalConfigurationAsync()
		{
			var value = "value";
			var obj1 = new CustomCacheKey(1, "test", false);
			var obj2 = new CustomCacheKey(1, "test", false);

			var props = GetDefaultProperties();
			var cacheProvider = ProviderBuilder();
			props[RedisEnvironment.AppendHashcode] = "true";
			cacheProvider.Start(props);
			var cache = cacheProvider.BuildCache(DefaultRegion, props);

			await (cache.PutAsync(obj1, value, CancellationToken.None));
			Assert.That(await (cache.GetAsync(obj1, CancellationToken.None)), Is.EqualTo(value), "Unable to retrieved cached object for key obj1");
			Assert.That(await (cache.GetAsync(obj2, CancellationToken.None)), Is.Null, "The hash code should be used in the cache key");
			await (cache.RemoveAsync(obj1, CancellationToken.None));
		}

		[Test]
		public async Task TestEqualObjectsWithDifferentHashCodeAndUseHashCodeRegionConfigurationAsync()
		{
			var value = "value";
			var obj1 = new CustomCacheKey(1, "test", false);
			var obj2 = new CustomCacheKey(1, "test", false);

			var props = GetDefaultProperties();
			var cacheProvider = ProviderBuilder();
			cacheProvider.Start(props);
			props["append-hashcode"] = "true";
			var cache = cacheProvider.BuildCache(DefaultRegion, props);

			await (cache.PutAsync(obj1, value, CancellationToken.None));
			Assert.That(await (cache.GetAsync(obj1, CancellationToken.None)), Is.EqualTo(value), "Unable to retrieved cached object for key obj1");
			Assert.That(await (cache.GetAsync(obj2, CancellationToken.None)), Is.Null, "The hash code should be used in the cache key");
			await (cache.RemoveAsync(obj1, CancellationToken.None));
		}

		[Test]
		public async Task TestNonEqualObjectsWithEqualToStringAsync()
		{
			var value = "value";
			var obj1 = new CustomCacheKey(new ObjectEqualToString(1), "test", true);
			var obj2 = new CustomCacheKey(new ObjectEqualToString(2), "test", true);

			var cache = GetDefaultCache();

			await (cache.PutAsync(obj1, value, CancellationToken.None));
			Assert.That(await (cache.GetAsync(obj1, CancellationToken.None)), Is.EqualTo(value), "Unable to retrieved cached object for key obj1");
			Assert.That(await (cache.GetAsync(obj2, CancellationToken.None)), Is.EqualTo(value), "Unable to retrieved cached object for key obj2");
			await (cache.RemoveAsync(obj1, CancellationToken.None));
		}

		[Test]
		public async Task TestNonEqualObjectsWithEqualToStringUseHashCodeAsync()
		{
			var value = "value";
			var obj1 = new CustomCacheKey(new ObjectEqualToString(1), "test", true);
			var obj2 = new CustomCacheKey(new ObjectEqualToString(2), "test", true);

			var props = GetDefaultProperties();
			var cacheProvider = ProviderBuilder();
			props[RedisEnvironment.AppendHashcode] = "true";
			cacheProvider.Start(props);
			var cache = cacheProvider.BuildCache(DefaultRegion, props);

			await (cache.PutAsync(obj1, value, CancellationToken.None));
			Assert.That(await (cache.GetAsync(obj1, CancellationToken.None)), Is.EqualTo(value), "Unable to retrieved cached object for key obj1");
			Assert.That(await (cache.GetAsync(obj2, CancellationToken.None)), Is.Null, "Unexpectedly found a cache entry for key obj2 after obj1 put");
			await (cache.RemoveAsync(obj1, CancellationToken.None));
		}

		[Test]
		public async Task TestEnvironmentNameAsync()
		{
			var props = GetDefaultProperties();

			var developProvider = ProviderBuilder();
			props[RedisEnvironment.EnvironmentName] = "develop";
			developProvider.Start(props);
			var developCache = developProvider.BuildCache(DefaultRegion, props);

			var releaseProvider = ProviderBuilder();
			props[RedisEnvironment.EnvironmentName] = "release";
			releaseProvider.Start(props);
			var releaseCache = releaseProvider.BuildCache(DefaultRegion, props);

			const string key = "testKey";
			const string value = "testValue";

			await (developCache.PutAsync(key, value, CancellationToken.None));

			Assert.That(await (releaseCache.GetAsync(key, CancellationToken.None)), Is.Null, "release environment should be separate from develop");

			await (developCache.RemoveAsync(key, CancellationToken.None));
			await (releaseCache.PutAsync(key, value, CancellationToken.None));

			Assert.That(await (developCache.GetAsync(key, CancellationToken.None)), Is.Null, "develop environment should be separate from release");

			await (releaseCache.RemoveAsync(key, CancellationToken.None));

			developProvider.Stop();
			releaseProvider.Stop();
		}
	}
}
